#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mpi.h> 

void Read_data(int* data_count_p, int* local_data_count_p, double* a_p, double* b_p,
	int* n_p, int comm_sz, int my_rank, MPI_Comm comm);
void Create_data(double local_data[], int local_data_count, int data_count, double a, double b, int my_rank, MPI_Comm comm);
void Create_bins(float bin_maxes[], int local_bin_counts[], double a, double b, int n, int my_rank, MPI_Comm comm);
void Assign_bins(int bin_counts[], double local_data[], int local_bin_counts[], int local_data_count, float bin_maxes[], int n, double a, MPI_Comm comm);

int main(void)
{
	int comm_sz, my_rank;
	MPI_Comm comm;
	double a, b;
	int n, data_count, local_data_count;
	int *bin_counts;
	double *data, *local_data;
	float *bin_maxes;
	int *local_bin_counts;



	MPI_Init(NULL, NULL);
	comm = MPI_COMM_WORLD;
	MPI_Comm_size(comm, &comm_sz);
	MPI_Comm_rank(comm, &my_rank);

	// Read data_count, a, b, and n
	Read_data(&data_count, &local_data_count, &a, &b, &n, comm_sz, my_rank, comm);

	// allocate memory
	bin_maxes = malloc(n * sizeof(float));
	bin_counts = malloc(n * sizeof(int));
	local_bin_counts = malloc(data_count * sizeof(int));
	data = malloc(data_count * sizeof(double));
	local_data = malloc(local_data_count * sizeof(double));


	// Set up n bins between the a & b range
	Create_bins(bin_maxes, local_bin_counts, a, b, n, my_rank, comm);
	// Generate data randomly
	Create_data(local_data, local_data_count, data_count, a, b, my_rank, comm);
	// Set the data in the bin
	Assign_bins(bin_counts, local_data, local_bin_counts, local_data_count, bin_maxes, b, a, comm);

	// return all bin counts from the processes to one singular array
	MPI_Reduce(local_bin_counts, bin_counts, n, MPI_INT, MPI_SUM, 0, comm);

	// print out everything
	if (my_rank == 0) {
		for (int i = 0; i < n; i++) {
			if (i == 0)
			{
				printf("[%10.2f-%10.2f] : ", a, bin_maxes[i]);
			}
			else {
				printf("[%10.2f-%10.2f] : ", bin_maxes[i - 1], bin_maxes[i]);
			}

			printf("%d", bin_counts[i]);
			printf("\n");
		}
	}

	MPI_Finalize();
	return 0;
}

int Assign_bins_helper(double item, float bin_maxes[], int n, double a)
{
	/*
	* This method goes through all bins to find which bin the current iterated local data belongs to
	* once this method finds the bin it belongs to, the function will return the index it breaks from
	* and this index will be used to add by 1 in the respective index of the local bin counts array
	*/
	int correctIndex;
	for (correctIndex = 0; correctIndex < n - 1; correctIndex++)
	{
		if (item <= bin_maxes[correctIndex]) {
			break;
		}
	}
	return correctIndex;
}

void Assign_bins(int bin_counts[], double local_data[], int local_bin_counts[], int local_data_count, float bin_maxes[], int n, double a, MPI_Comm comm)
{
	int i;
	int correctBin;
	int Assign_bins_helper(double item, float bin_maxes[], int n, double a);

	// go through 
	for (i = 0; i < local_data_count; i++)
	{
		// send info to the helper method
		correctBin = Assign_bins_helper(local_data[i], bin_maxes, n, a);
		// add 1 to the index returned by correctBin
		local_bin_counts[correctBin]++;
	}
}

void Create_bins(float bin_maxes[], int local_bin_counts[], double a, double b, int n, int my_rank, MPI_Comm comm)
{
	// find the interval of the bin of the current process
	double intervalOfBin = (b - a) / n;
	int i;

	for (i = 0; i < n; i++)
	{
		// set the max value of the bin
		bin_maxes[i] = intervalOfBin * (float)(i + 1) + a;
		// create array which keeps track of the amount of items that are in each bin
		local_bin_counts[i] = 0;
	}
}

void Create_data(double local_data[], int local_data_count, int data_count, double a, double b, int my_rank, MPI_Comm comm)
{
	// create array variable
	double *data;
	if (my_rank == 0) 
	{
		// find distance between bounds
		float distance = b - a;
		int i;
		// allocate memory for the array
		data = malloc(data_count * sizeof(double));

		printf("Randomly Generated Data: \n");
		for (i = 0; i < data_count; i++)
		{
			// data is generated by using the rand() function
			// this formula ensures it generates a random value between the lower and upward bound
			data[i] = (double)rand() / (double)RAND_MAX * (distance + a);
			printf("%f ", data[i]);
		}
		printf("\n");
	}

	// send the required data to each process with scatter
	MPI_Scatter(data, local_data_count, MPI_DOUBLE, local_data, local_data_count, MPI_DOUBLE, 0, comm);

	if (my_rank == 0)
	{
		free(data);
	}

}

void Read_data(int* data_count_p, int* local_data_count_p, double* a_p, double* b_p, int* n_p, int comm_sz, int my_rank, MPI_Comm comm)
{
	if (my_rank == 0) {
		// read the amount of bins, lower bound, upward bound, and amount of data to generate
		printf("Enter the amount of bins: \n");
		scanf("%d", n_p);
		printf("Enter the lower bound (a): \n");
		scanf("%lf", a_p);
		printf("Enter the upper bound (b): \n");
		scanf("%lf", b_p);
		printf("Enter the data count (Number of values): \n");
		scanf("%d", data_count_p);

		// set the amount of data each process takes from the total data
		*local_data_count_p = *data_count_p / comm_sz;
		*data_count_p = *local_data_count_p * comm_sz;
	}

	// use MPI_Bcast to make each process aware of the variables
	MPI_Bcast(a_p, 1, MPI_DOUBLE, 0, comm);
	MPI_Bcast(b_p, 1, MPI_DOUBLE, 0, comm);
	MPI_Bcast(data_count_p, 1, MPI_INT, 0, comm);
	MPI_Bcast(local_data_count_p, 1, MPI_INT, 0, comm);
	MPI_Bcast(n_p, 1, MPI_INT, 0, comm);
}